---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by lzh.
--- DateTime: 2024-11-19 10:30
---
RaffleCtrl = {}
require("Download/xLuaLogic/Common/Define")

local util = require 'xlua.util'
local this = RaffleCtrl
local transform;
local gameObject;
local items;-- 抽奖物品数据
local pool;-- 物品预制体池
local ItemContent
local itemPosX = -392 --抽奖物品位置X
local itemPosY = 242  --抽奖物品位置Y
local itemPosXStep = 250  --抽奖物品位置X步长
local itemPosYStep = 220  --抽奖物品位置Y步长
local prefabList = {}
local isAnimating = false
local yield_return
local function async_yield_return(to_yield, cb)
    RaffleView.gameBehaviour:YieldAndCallback(to_yield, cb)        -- 调用 C# 函数
    end

function RaffleCtrl.New()
    return this
end
function RaffleCtrl.Awake()
    print("RaffleCtrl Awake")

    transform = LuaHelper.MainCitySys.shopWnd.RaffleSlots.transform
    gameObject = transform.gameObject
    gameObject:SetActive(true)

    yield_return=util.async_to_sync(async_yield_return)
    CS.GameObjectExt.GetOrAddLuaComponent(gameObject)
    -- 注册事件监听
    LuaHelper:AddEventListener(CMD.RspRaffleSingle, this.OnRspRaffleSingle)
    LuaHelper:AddEventListener(CMD.RspRaffleTan, this.OnRspRaffleTan)

    this.Clear()
    -- 加载物品预制体
    if pool == nil then
        LuaHelper.MainCitySys.shopWnd.DownLoadUrl=CS.PathDefine.RaffleItem
        LuaHelper.MainCitySys.shopWnd.DownLoad.gameObject:SetActive(true)
        CS.LuaHelper.Instance.AssetLoaderSvc:LoadPrefab(CS.PathDefine.ResItem, CS.PathDefine.RaffleItem, this.OnPoolCreate)
    else
        this.LoadPrefabItem()
    end
end
-- 创建物品预制体
function RaffleCtrl.OnPoolCreate(obj)
    items = LuaHelper.ResSvc:GetRaffleItemCfgData()

    print("items length = " .. type(items))
    pool = CS.LuaHelper.Instance.GameObjectPoolManager:CreatePrefabPool(obj);
    pool.MaxCount = 15;
    pool.cullMaxPerPass = 5;
    pool.cullAbove = 15;
    pool.cullDespawned = true;
    pool.cullDelay = 2;
    pool:Init();
    this.LoadPrefabItem()
end
-- 接收服务器单抽结果
function RaffleCtrl.OnRspRaffleSingle(msg)
    CS.GameRoot.AddTips("抽奖成功");
    local  rspRaffleSingle = msg.rspRaffleSingle;
    local playerData =  LuaHelper.GameRoot.PlayerData;
    playerData.Bag = rspRaffleSingle.Bag;
    playerData.aura = rspRaffleSingle.aura;
    playerData.ruvia = rspRaffleSingle.ruvia;
    playerData.crystal = rspRaffleSingle.crystal;
    local targetId = rspRaffleSingle.RaffleId;
    LuaHelper.MainCitySys:RefreshUI();
    -- 播放抽奖动画
    local co = coroutine.create(function()
        RaffleCtrl.PlayRaffleAnimation(targetId)
    end )
    coroutine.resume(co)
end
-- 接收服务器十连抽结果
function RaffleCtrl.OnRspRaffleTan(msg)
    CS.GameRoot.AddTips("抽奖成功");
    local  rspRaffleTan = msg.rspRaffleTan;
    local playerData =  LuaHelper.GameRoot.PlayerData;
    playerData.Bag = rspRaffleTan.Bag;
    playerData.aura = rspRaffleTan.aura;
    playerData.ruvia = rspRaffleTan.ruvia;
    playerData.crystal = rspRaffleTan.crystal;
    local targetId = rspRaffleTan.RaffleList;
    LuaHelper.MainCitySys:RefreshUI();
    local randomIds={}
    print("targetId length = " .. targetId.Count)
    for i = 0,targetId.Count-1 ,1 do
        table.insert(randomIds, targetId[i]) -- 允许重复添加
    end
    -- 播放抽奖动画
    local co = coroutine.create(function()
        RaffleCtrl.PlayTanRaffleAnimation(randomIds)
    end )
    coroutine.resume(co)
end

-- 单抽按钮点击事件
function RaffleCtrl.OnSingledrawBtn()
    if isAnimating then
        return
    end
    isAnimating=true
    this.RaffleColorClear()
    -- 创建 GameMsg 对象
    local gameMsg = CS.CommonNet.GameMsg()  -- 使用 CS 前缀来实例化 C# 类

    -- 设置 gameMsg 的属性
    gameMsg.cmd = CMD.ReqRaffleSingle:GetHashCode() -- 枚举类型直接使用 CS.CMD.ReqShop（假设 XLua 支持直接映射枚举）

    gameMsg.reqRaffleSingle = CS.CommonNet.ReqRaffleSingle()  -- 实例化 reqShop 对象

    gameMsg.reqRaffleSingle.id = LuaHelper.GameRoot.PlayerData.id  -- 使用 tonumber() 将字符串转换为数字
    LuaHelper.NetSvc:SendMsg(gameMsg);
end

function RaffleCtrl.PlayRaffleAnimation(targetId)
    local speed = 1 -- 初始速度
    local duration = 3.0  -- 总动画时长（秒）
    local startTime = CS.UnityEngine.Time.time
    -- 当前选中的物品ID（初始化为0，表示没有选中）
    local currentIndex = 0

    -- 找到目标物品的索引
    local targetIndex = 1
    for i = 1, #prefabList, 1 do
        if targetId == prefabList[i].mShopID then
            targetIndex = i
            break
        end
    end

    -- 协程执行的循环
    while true do
        -- 计算已过时间
        local elapsedTime = CS.UnityEngine.Time.time - startTime
        local remainingTime = duration - elapsedTime

        -- 计算当前速度（从快到慢）
        local t = math.min(elapsedTime / duration, 1)  -- 归一化时间 (0~1)
        local currentSpeed = speed * t  -- 开始快，逐渐变慢慢

        -- 恢复上一个选中的物品颜色为白色
        if currentIndex > 0 then
            prefabList[currentIndex]:GetComponent("UnityEngine.UI.Image").color = Color.white
        end

        -- 计算当前需要选中的物品
        if remainingTime > 0.5 then
            -- 时间还剩足够时，按正常逻辑循环选择
            currentIndex = (currentIndex % #prefabList) + 1
        else
            -- 时间不足时，逐渐接近目标物品
            if currentIndex ~= targetIndex then
                currentIndex = (currentIndex % #prefabList) + 1
            end
        end

        -- 当前选中的物品变为绿色
        prefabList[currentIndex]:GetComponent("UnityEngine.UI.Image").color =  Color(0.8, 0.8, 0.8, 1)
        -- 计算本次遍历的间隔时间
        local waitTime = math.max(currentSpeed * 0.1, 0.02)  -- 最低间隔 0.05 秒
        -- 使用协程的 yield 来延迟每一帧
        yield_return(CS.UnityEngine.WaitForSeconds(waitTime))

        -- 如果动画时间已经结束并且选中了目标物品，退出循环
        if elapsedTime >= duration and currentIndex == targetIndex then
            break
        end
    end

    -- 动画完成后确保停留在目标物品上
    prefabList[currentIndex]:GetComponent("UnityEngine.UI.Image").color = Color(0.58, 0.44, 0.86, 1)
    isAnimating=false
    -- 显示抽奖结果
    local targetShop = LuaHelper.ResSvc: GetRaffleItemCfgShopId(targetId)
   local  RaffleTipContent = RaffleView.RaffleTipInfoContent
    RaffleView.RaffleTipInfoTrans.gameObject:SetActive(true)
    RaffleView.btn_Close.onClick:AddListener(this.OnRaffleTipClose)
    RaffleView.SureBtn.onClick:AddListener(this.OnRaffleTipClose)
    for i = RaffleTipContent.childCount - 1, 0, -1 do
        pool:ReturnObject(RaffleTipContent.transform:GetChild(i).gameObject);
    end
    -- 创建物品预制体
    local itemObj = pool:GetObject()
    itemObj.transform:SetParent(RaffleTipContent.transform, false)
    -- 设置物品的位置
    itemObj.transform.localPosition = Vector3.zero
    itemObj.transform.localScale = Vector3.one
    -- 设置物品数据
    local RaffleItem = itemObj:GetComponent(typeof(CS.RaffleItem))

    RaffleItem:SetUI(targetShop)
end

function RaffleCtrl.OnTandrawBtn()
    if isAnimating then
        return
    end
    isAnimating=true
    this.RaffleColorClear()
    -- 创建 GameMsg 对象
    local gameMsg = CS.CommonNet.GameMsg()  -- 使用 CS 前缀来实例化 C# 类

    -- 设置 gameMsg 的属性
    gameMsg.cmd = CMD.ReqRaffleTan:GetHashCode() -- 枚举类型直接使用 CS.CMD.ReqShop（假设 XLua 支持直接映射枚举）

    gameMsg.reqRaffleTan = CS.CommonNet.ReqRaffleTan()  -- 实例化 reqShop 对象

    gameMsg.reqRaffleTan.Id = LuaHelper.GameRoot.PlayerData.id  -- 使用 tonumber() 将字符串转换为数字
    LuaHelper.NetSvc:SendMsg(gameMsg);

end
-- 播放十连抽动画
function RaffleCtrl.PlayTanRaffleAnimation(targetIds)
    local speed = 1         -- 初始速度
    local duration = 5.0    -- 动画总时长（秒）
    local startTime = CS.UnityEngine.Time.time
    local currentIndex = 0  -- 当前选中的物品索引
    local selectedTargetIndex = 1 -- 当前需要选中的目标物品索引
    local targetIndexReached = false -- 是否已经开始选中目标物品
    local selectedTargets = {}  -- 已选中的物品索引

    while true do
        -- 计算已过时间
        local elapsedTime = CS.UnityEngine.Time.time - startTime
        local remainingTime = duration - elapsedTime
        -- 计算当前速度（从快到慢）
        local t = math.min(elapsedTime / duration, 1)  -- 归一化时间 (0~1)
        local currentSpeed = speed * t  -- 开始快，逐渐变慢慢
        -- 如果当前物品已被选中，不改变颜色
        if not selectedTargets[currentIndex] and currentIndex > 0 then
            prefabList[currentIndex]:GetComponent("UnityEngine.UI.Image").color = Color.white
        end

        -- 如果剩余时间 > 0.5 秒，继续快速循环选中物品
        if remainingTime > 0.5 then
            currentIndex = (currentIndex % #prefabList) + 1
        else
            -- 逐步接近目标，锁定目标物品
            if selectedTargetIndex <= #targetIds then
                local targetIndex = RaffleCtrl.FindTargetIndex(targetIds[selectedTargetIndex])

                if currentIndex ~= targetIndex then
                    currentIndex = (currentIndex % #prefabList) + 1
                else

                    prefabList[currentIndex]:GetComponent("UnityEngine.UI.Image").color = Color(0.58, 0.44, 0.86, 1)
                    selectedTargets[currentIndex] = true
                    selectedTargetIndex = selectedTargetIndex + 1
                end
            else
                targetIndexReached = true
            end
        end

        -- 如果未选中，当前物品变为灰色；选中后保持紫色
        if not selectedTargets[currentIndex] then
            prefabList[currentIndex]:GetComponent("UnityEngine.UI.Image").color = Color(0.8, 0.8, 0.8, 1)
        end

        -- 计算本次遍历的间隔时间
        local waitTime = math.max(currentSpeed * 0.1, 0.02)  -- 最低间隔 0.03 秒
        yield_return(CS.UnityEngine.WaitForSeconds(waitTime))

        -- 如果动画时间已经结束并且所有目标物品都已依次选中，退出循环
        if elapsedTime >= duration and targetIndexReached then
            break
        end
    end

    -- 动画完成后，确保最终选中的目标物品停留在紫色
    RaffleCtrl.HighlightSelectedTargets(targetIds)
    isAnimating = false
end

-- 找到目标物品的索引
function RaffleCtrl.FindTargetIndex(targetId)
    for i = 1, #prefabList do
        if targetId == prefabList[i].mShopID then
            return i
        end
    end
    return 1  -- 如果未找到，默认返回第一个物品
end

-- 高亮显示最终选中的十个物品
function RaffleCtrl.HighlightSelectedTargets(targetIds)
    local  RaffleTipContent = RaffleView.RaffleTipInfoContent
    RaffleView.RaffleTipInfoTrans.gameObject:SetActive(true)

    RaffleView.btn_Close.onClick:AddListener(this.OnRaffleTipClose)
    RaffleView.SureBtn.onClick:AddListener(this.OnRaffleTipClose)
    for i = RaffleTipContent.childCount - 1, 0, -1 do
        pool:ReturnObject(RaffleTipContent.transform:GetChild(i).gameObject);
    end
    print("targetIds length = ".. #targetIds)
    for _, targetId in ipairs(targetIds) do
        local index = RaffleCtrl.FindTargetIndex(targetId)
        prefabList[index]:GetComponent("UnityEngine.UI.Image").color = Color(0.58, 0.44, 0.86, 1)
        -- 显示抽奖结果
        local targetShop = LuaHelper.ResSvc: GetRaffleItemCfgShopId(targetId)
        -- 创建物品预制体
        local itemObj = pool:GetObject()
        itemObj.transform:SetParent(RaffleTipContent.transform, false)
        -- 设置物品的位置
        itemObj.transform.localPosition = Vector3.zero
        itemObj.transform.localScale = Vector3.one
        -- 设置物品数据
        local RaffleItem = itemObj:GetComponent(typeof(CS.RaffleItem))

        RaffleItem:SetUI(targetShop)
    end
end


-- 加载物品预制体
function RaffleCtrl.LoadPrefabItem()
    LuaHelper.MainCitySys.shopWnd.DownLoadUrl=nil
    LuaHelper.MainCitySys.shopWnd.DownLoad.gameObject:SetActive(false)
    RaffleView.SingledrawBtn.onClick:AddListener(this.OnSingledrawBtn)
    RaffleView.TandrawBtn.onClick:AddListener(this.OnTandrawBtn)
    local columnCount = 4 -- 每行显示的列数
    local offsetCount = 0 -- 偏移的数量
    prefabList = {} -- 定义一个列表，用于存储所有的物品预制体
    for i = 0, items.Length - 1, 1 do
        -- 创建物品预制体
        local itemObj = pool:GetObject()
        itemObj.transform:SetParent(ItemContent.transform, false)

        -- 修正索引计算，包括偏移量
        local adjustedIndex = i + offsetCount
        local currentRow = math.floor(adjustedIndex / columnCount) -- 当前行索引（从0开始）
        local currentCol

        -- 判断当前行是偶数行还是奇数行
        if currentRow % 2 == 0 then
            -- 偶数行，正常排列（从左到右）
            currentCol = adjustedIndex % columnCount
        else
            -- 奇数行，反向排列（从右到左）
            currentCol = columnCount - 1 - (adjustedIndex % columnCount)
        end

        -- 特殊偏移逻辑
        if currentRow + 1 == 2 and (currentCol + 1 == 3) then
            offsetCount = offsetCount + 2 -- 偏移数量
            adjustedIndex = i + offsetCount -- 重新计算调整后的索引
            currentRow = math.floor(adjustedIndex / columnCount)
            -- 重新计算列索引，确保反向排列逻辑
            if currentRow % 2 == 0 then
                currentCol = adjustedIndex % columnCount
            else
                currentCol = columnCount - 1 - (adjustedIndex % columnCount)
            end
        end

        -- 设置物品的位置
        itemObj.transform.localPosition = Vector3(
                itemPosX + currentCol * itemPosXStep,
                itemPosY - currentRow * itemPosYStep,
                0
        )
        itemObj.transform.localScale = Vector3.one

        -- 设置物品数据
        local RaffleItem = itemObj:GetComponent(typeof(CS.RaffleItem))
        local itemData = items[i]
        RaffleItem:SetUI(itemData)

        -- 将当前物品预制体添加到列表中
        table.insert(prefabList, RaffleItem)
    end
    -- 调整prefabList的顺序
    local halfIndex = math.floor(#prefabList / 2) + 1
    local secondHalf = {}

    -- 提取后半部分并反转
    local secondHalf = {}  -- 创建一个表用于存储后半部分

    -- 提取后半部分
    for i = halfIndex, #prefabList do
        table.insert(secondHalf, prefabList[i])  -- 将后半部分元素加入到 secondHalf
    end

    -- 反转并修改原表
    local reverseIndex = #secondHalf  -- 反转后的索引
    for i = halfIndex, #prefabList do
        if reverseIndex > 0 then
            prefabList[i] = secondHalf[reverseIndex]  -- 直接修改 prefabList 中的元素
            reverseIndex = reverseIndex - 1  -- 更新索引，继续反向填充
        end
    end

end
-- 清空抽奖物品颜色
function RaffleCtrl.RaffleColorClear()
    for i = 1, #prefabList, 1 do
        prefabList[i]:GetComponent("UnityEngine.UI.Image").color = Color.white
    end
end

-- 刷新商店物品
function RaffleCtrl.Clear()
    ItemContent = RaffleView.ItemContent
    if ItemContent ~= nil then
        -- 清空当前的商店物品

        if pool ~= nil then
            for i = ItemContent.transform.childCount - 1, 0, -1 do
                pool:ReturnObject(ItemContent.transform:GetChild(i).gameObject);
            end
        else
            for i = ItemContent.transform.childCount - 1, 0, -1 do
                GameObject.Destroy(ItemContent.transform:GetChild(i).gameObject);

            end
        end
    end
end
function RaffleCtrl.OnRaffleTipClose()
    RaffleView.btn_Close.onClick:RemoveListener(this.OnRaffleTipClose)
    RaffleView.SureBtn.onClick:RemoveListener(this.OnRaffleTipClose)
    RaffleView.RaffleTipInfoTrans.gameObject:SetActive(false)
end
function RaffleCtrl.OnDestroy()
    print("RaffleCtrl OnDestroy")
    isAnimating = false
    if prefabList~=nil then

        this.RaffleColorClear()
    end
    if RaffleView.SingledrawBtn ~= nil then

        RaffleView.SingledrawBtn.onClick:RemoveListener(this.OnSingledrawBtn)
    end
    if RaffleView.TandrawBtn ~= nil then

        RaffleView.TandrawBtn.onClick:RemoveListener(this.OnTandrawBtn)
    end
    LuaHelper:RemoveEventListener(CMD.RspRaffleSingle, this.OnRspRaffleSingle)
    LuaHelper:RemoveEventListener(CMD.RspRaffleTan, this.OnRspRaffleTan)
end
